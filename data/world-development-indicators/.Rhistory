policy <- ifelse(post==1 & treated==1, 1, 0)
# # hyperparameters:
mu.b0.true <- 120        # more generally, these could
sigma.b0.true <- 0.5*sd_m
mu.b1.true <- 0.25*sd_m      # be specified as additional
mu.b2.true <- 0.25*sd_m       # arguments to the function
mu.b3.true <- mu_b3
mu.g0.true <- 130
sigma.g0.true <- 0.05*sd_y
mu.g1.true <- 0.4*sd_y
mu.g2.true <- 0.2*sd_y
mu.g3.true <- mu_g3
mu.g4.true <- mu_g4
sigma.m.true <- sd_m
sigma.y.true <- sd_y
# # village-level parameters
b0.true <- rnorm(50, mu.b0.true, sigma.b0.true)
b1.true <- rnorm(50, mu.b1.true, 0.2)
b2.true <- rnorm(50, mu.b2.true, 0.2)
b3.true <- rnorm(50, mu.b3.true, 0.2)
g0.true <- rnorm(50, mu.g0.true, sigma.g0.true)
g1.true <- rnorm(50, mu.g1.true, 0.2)
g2.true <- rnorm(50, mu.g2.true, 0.2)
g3.true <- rnorm(50, mu.g3.true, 0.2)
g4.true <- rnorm(50, mu.g4.true, 0.2)
# # data
mm <- b0.true[village] + b1.true[village]*treated
+ b2.true[village]*post + b3.true[village]*policy
s <- sigma.m.true
location <- log(mm^2 / sqrt(s^2 + mm^2))
shape <- sqrt(log(1 + (s^2 / mm^2)))
# m <- rnorm (50*19*3, b0.true[village] + b1.true[village]*treated
# + b2.true[village]*post + b3.true[village]*policy, sigma.m.true)
m <- rlnorm(50*19*3, location, shape)
y <- rnorm (50*19*3, g0.true[village] + g1.true[village]*treated
+ g2.true[village]*post + g3.true[village]*policy
+ g4.true[village]*log(m), sigma.y.true)
return (data.frame (y, m, wave, person, village, treatment, treated, policy))
}
lme.power.ym <- lmer (m ~ (1 | village), data=test2)
sjstats::icc(lme.power.ym)
test2 <- BHET.fake(20, 2, 1, 40, 10)
lme.power.ym <- lmer (m ~ (1 | village), data=test2)
sjstats::icc(lme.power.ym)
lme.m <- lmer(m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
hist(test2$m)
summary(test2$m)
test2 <- BHET.fake(50, 2, 1, 40, 10)
lme.m <- lmer(m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
test2 <- BHET.fake(5, 2, 1, 40, 10)
hist(test2$m)
lme.m <- lmer(m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
test2 <- BHET.fake(5, 2, 1, 20, 10)
lme.m <- lmer(m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
## Multi-level power calculations from Gelman's ARM book:
BHET.fake <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y){
wave <- rep (seq(1,3,1), 19*50)
person <- rep (1:19, each=3)           # person ID’s
village <- rep (1:50, each=19*3)
treatment <- sample (rep (0:1, 50/2))
treated <- treatment[village]
post <- ifelse(wave > 1, 1, 0)
policy <- ifelse(post==1 & treated==1, 1, 0)
# # hyperparameters:
mu.b0.true <- 120        # more generally, these could
sigma.b0.true <- 0.1*sd_m
mu.b1.true <- 0.25*sd_m      # be specified as additional
mu.b2.true <- 0.25*sd_m       # arguments to the function
mu.b3.true <- mu_b3
mu.g0.true <- 130
sigma.g0.true <- 0.05*sd_y
mu.g1.true <- 0.4*sd_y
mu.g2.true <- 0.2*sd_y
mu.g3.true <- mu_g3
mu.g4.true <- mu_g4
sigma.m.true <- sd_m
sigma.y.true <- sd_y
# # village-level parameters
b0.true <- rnorm(50, mu.b0.true, sigma.b0.true)
b1.true <- rnorm(50, mu.b1.true, 0)
b2.true <- rnorm(50, mu.b2.true, 0)
b3.true <- rnorm(50, mu.b3.true, 0)
g0.true <- rnorm(50, mu.g0.true, sigma.g0.true)
g1.true <- rnorm(50, mu.g1.true, 0)
g2.true <- rnorm(50, mu.g2.true, 0)
g3.true <- rnorm(50, mu.g3.true, 0)
g4.true <- rnorm(50, mu.g4.true, 0)
# # data
mm <- b0.true[village] + b1.true[village]*treated
+ b2.true[village]*post + b3.true[village]*policy
s <- sigma.m.true
location <- log(mm^2 / sqrt(s^2 + mm^2))
shape <- sqrt(log(1 + (s^2 / mm^2)))
# m <- rnorm (50*19*3, b0.true[village] + b1.true[village]*treated
# + b2.true[village]*post + b3.true[village]*policy, sigma.m.true)
m <- rlnorm(50*19*3, location, shape)
y <- rnorm (50*19*3, g0.true[village] + g1.true[village]*treated
+ g2.true[village]*post + g3.true[village]*policy
+ g4.true[village]*log(m), sigma.y.true)
return (data.frame (y, m, wave, person, village, treatment, treated, policy))
}
test2 <- BHET.fake(5, 2, 1, 50, 10)
lme.m <- lmer(m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
test2 <- BHET.fake(10, 2, 1, 50, 10)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
lme.m <- lmer (m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
## Multi-level power calculations from Gelman's ARM book:
BHET.fake <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y){
wave <- rep (seq(1,3,1), 19*50)
person <- rep (1:19, each=3)           # person ID’s
village <- rep (1:50, each=19*3)
treatment <- sample (rep (0:1, 50/2))
treated <- treatment[village]
post <- ifelse(wave > 1, 1, 0)
policy <- ifelse(post==1 & treated==1, 1, 0)
# # hyperparameters:
mu.b0.true <- 120        # more generally, these could
sigma.b0.true <- 0.1*sd_m
mu.b1.true <- 0.5*sd_m      # be specified as additional
mu.b2.true <- 0.5*sd_m       # arguments to the function
mu.b3.true <- mu_b3
mu.g0.true <- 130
sigma.g0.true <- 0.05*sd_y
mu.g1.true <- 0.4*sd_y
mu.g2.true <- 0.2*sd_y
mu.g3.true <- mu_g3
mu.g4.true <- mu_g4
sigma.m.true <- sd_m
sigma.y.true <- sd_y
# # village-level parameters
b0.true <- rnorm(50, mu.b0.true, sigma.b0.true)
b1.true <- rnorm(50, mu.b1.true, 0)
b2.true <- rnorm(50, mu.b2.true, 0)
b3.true <- rnorm(50, mu.b3.true, 0)
g0.true <- rnorm(50, mu.g0.true, sigma.g0.true)
g1.true <- rnorm(50, mu.g1.true, 0)
g2.true <- rnorm(50, mu.g2.true, 0)
g3.true <- rnorm(50, mu.g3.true, 0)
g4.true <- rnorm(50, mu.g4.true, 0)
# # data
mm <- b0.true[village] + b1.true[village]*treated
+ b2.true[village]*post + b3.true[village]*policy
s <- sigma.m.true
location <- log(mm^2 / sqrt(s^2 + mm^2))
shape <- sqrt(log(1 + (s^2 / mm^2)))
# m <- rnorm (50*19*3, b0.true[village] + b1.true[village]*treated
# + b2.true[village]*post + b3.true[village]*policy, sigma.m.true)
m <- rlnorm(50*19*3, location, shape)
y <- rnorm (50*19*3, g0.true[village] + g1.true[village]*treated
+ g2.true[village]*post + g3.true[village]*policy
+ g4.true[village]*log(m), sigma.y.true)
return (data.frame (y, m, wave, person, village, treatment, treated, policy))
}
lme.m <- lmer (m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
test2 <- BHET.fake(25, 2, 1, 50, 10)
lme.m <- lmer (m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
sjstats::icc(lme.m)
## Multi-level power calculations from Gelman's ARM book:
BHET.fake <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y){
wave <- rep (seq(1,3,1), 19*50)
person <- rep (1:19, each=3)           # person ID’s
village <- rep (1:50, each=19*3)
treatment <- sample (rep (0:1, 50/2))
treated <- treatment[village]
post <- ifelse(wave > 1, 1, 0)
policy <- ifelse(post==1 & treated==1, 1, 0)
# # hyperparameters:
mu.b0.true <- 120        # more generally, these could
sigma.b0.true <- 0.1*sd_m
mu.b1.true <- 0      # be specified as additional
mu.b2.true <- 0       # arguments to the function
mu.b3.true <- mu_b3
mu.g0.true <- 130
sigma.g0.true <- 0.05*sd_y
mu.g1.true <- 0.4*sd_y
mu.g2.true <- 0.2*sd_y
mu.g3.true <- mu_g3
mu.g4.true <- mu_g4
sigma.m.true <- sd_m
sigma.y.true <- sd_y
# # village-level parameters
b0.true <- rnorm(50, mu.b0.true, sigma.b0.true)
b1.true <- rnorm(50, mu.b1.true, 0)
b2.true <- rnorm(50, mu.b2.true, 0)
b3.true <- rnorm(50, mu.b3.true, 0)
g0.true <- rnorm(50, mu.g0.true, sigma.g0.true)
g1.true <- rnorm(50, mu.g1.true, 0)
g2.true <- rnorm(50, mu.g2.true, 0)
g3.true <- rnorm(50, mu.g3.true, 0)
g4.true <- rnorm(50, mu.g4.true, 0)
# # data
mm <- b0.true[village] + b1.true[village]*treated
+ b2.true[village]*post + b3.true[village]*policy
s <- sigma.m.true
location <- log(mm^2 / sqrt(s^2 + mm^2))
shape <- sqrt(log(1 + (s^2 / mm^2)))
# m <- rnorm (50*19*3, b0.true[village] + b1.true[village]*treated
# + b2.true[village]*post + b3.true[village]*policy, sigma.m.true)
m <- rlnorm(50*19*3, location, shape)
y <- rnorm (50*19*3, g0.true[village] + g1.true[village]*treated
+ g2.true[village]*post + g3.true[village]*policy
+ g4.true[village]*log(m), sigma.y.true)
return (data.frame (y, m, wave, person, village, treatment, treated, policy))
}
lme.m <- lmer (m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.m)
mean(test2$m)
hist(test2$y)
hist(test2$m)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
test2 <- BHET.fake(1, 2, 1, 50, 10)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
lme.m <- lmer (m ~ treated + post + policy + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
## Multi-level power calculations from Gelman's ARM book:
BHET.fake <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y){
wave <- rep (seq(1,3,1), 19*50)
person <- rep (1:19, each=3)           # person ID’s
village <- rep (1:50, each=19*3)
treatment <- sample (rep (0:1, 50/2))
treated <- treatment[village]
post <- ifelse(wave > 1, 1, 0)
policy <- ifelse(post==1 & treated==1, 1, 0)
# # hyperparameters:
mu.b0.true <- 120        # more generally, these could
sigma.b0.true <- 0.1*sd_m
mu.b1.true <- 0.2*sd_m      # be specified as additional
mu.b2.true <- 0.2*sd_m       # arguments to the function
mu.b3.true <- mu_b3
mu.g0.true <- 130
sigma.g0.true <- 0.05*sd_y
mu.g1.true <- 0.4*sd_y
mu.g2.true <- 0.2*sd_y
mu.g3.true <- mu_g3
mu.g4.true <- mu_g4
sigma.m.true <- sd_m
sigma.y.true <- sd_y
# # village-level parameters
b0.true <- rnorm(50, mu.b0.true, sigma.b0.true)
b1.true <- rnorm(50, mu.b1.true, 0)
b2.true <- rnorm(50, mu.b2.true, 0)
b3.true <- rnorm(50, mu.b3.true, 0)
g0.true <- rnorm(50, mu.g0.true, sigma.g0.true)
g1.true <- rnorm(50, mu.g1.true, 0)
g2.true <- rnorm(50, mu.g2.true, 0)
g3.true <- rnorm(50, mu.g3.true, 0)
g4.true <- rnorm(50, mu.g4.true, 0)
# # data
mm <- b0.true[village] + b1.true[village]*treated
+ b2.true[village]*post + b3.true[village]*policy
s <- sigma.m.true
location <- log(mm^2 / sqrt(s^2 + mm^2))
shape <- sqrt(log(1 + (s^2 / mm^2)))
# m <- rnorm (50*19*3, b0.true[village] + b1.true[village]*treated
# + b2.true[village]*post + b3.true[village]*policy, sigma.m.true)
m <- rlnorm(50*19*3, location, shape)
y <- rnorm (50*19*3, g0.true[village] + g1.true[village]*treated
+ g2.true[village]*post + g3.true[village]*policy
+ g4.true[village]*log(m), sigma.y.true)
return (data.frame (y, m, wave, person, village, treatment, treated, policy))
}
test2 <- BHET.fake(10, 2, 1, 50, 10)
summary(test2)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
summary(lme.power.y)
plot(test2$m, test2$y)
plot(log(test2$m), test2$y)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
summary(lme.power.ym)
test2 <- BHET.fake(10, 2, 10, 50, 10)
plot(test2$m, test2$y)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
test2 <- BHET.fake(10, 5, 5, 50, 10)
lme.power.y <- lmer (y ~ treated + post + policy + (1 | village), data=test2)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
summary(lme.power.y)
summary(lme.power.ym)
cde.hat <- fixef(lme.power.ym)["policy"]
cde.se <- se.fixef(lme.power.ym)["policy"]
??`lme4-package`
cde.se <- fixef.se(lme.power.ym)["policy"]
se.fixef(lme.power.ym)
fixef(lme.power.ym)
fixef.se(lme.power.ym)
sefixef(lme.power.ym)
fixefse(lme.power.ym)
??fixef
se.coef(lme.power.ym)
fixef
library(nlme)
se.coef(lme.power.ym)
se.fixef(lme.power.ym)
se.coeff(lme.power.ym)
se.coef(lme.power.ym)
??se.fixef
library(arm)
se.fixef(lme.power.ym)
# power calculation function
BHET.power <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y, n.sims=10){
signif <- rep (NA, n.sims)
for (s in 1:n.sims){
fake <- BHET.fake (mu_b3, mu_g3, mu_g4, sd_m, sd_y)
lme.power.te <- lmer (y ~ treated + post + policy +
(1 | village), data=fake)
te.hat <- fixef(lme.power.te)["policy"]
te.se <- se.fixef(lme.power.te)["policy"]
te.signif[s] <- (te.hat - 2*te.se) > 0 # returns TRUE or FALSE
lme.power.cde <- lmer (y ~ treated + post + policy + m +
(1 | village), data=fake)
cde.hat <- fixef(lme.power.cde)["policy"]
cde.se <- se.fixef(lme.power.cde)["policy"]
cde.signif[s] <- (cde.hat - 2*cde.se) > 0 # returns TRUE or FALSE
}
power.te <- mean (te.signif)
return (power.te)
power.cde <- mean (cde.signif) # proportion of TRUE
return (power.cde)
}
BHET.power (mu_b3=10, mu_g3=5, mu_g4=5, sd_m=50, sd_y=10, n.sims=10)
## Multi-level power calculations from Gelman's ARM book:
CD4.fake <- function (J, K){
time <- rep (seq(0,1,length=K), J)    # K measurements during the year
person <- rep (1:J, each=K)           # person ID’s
treatment <- sample (rep (0:1, J/2))
treatment1 <- treatment[person]
# # hyperparameters:
mu.a.true <- 4.8     # more generally, these could
g.0.true <- -.5      # be specified as additional
g.1.true <- .5       # arguments to the function
sigma.y.true <- .7
sigma.a.true <- 1.3
sigma.b.true <- .7
# # person-level parameters
a.true <- rnorm (J, mu.a.true, sigma.a.true)
b.true <- rnorm (J, g.0.true + g.1.true*treatment, sigma.b.true)
# # data
y <- rnorm (J*K, a.true[person] + b.true[person]*time, sigma.y.true)
return (data.frame (y, time, person, treatment1))
}
# power calculation function
CD4.power <- function (J, K, n.sims=1000){
signif <- rep (NA, n.sims)
for (s in 1:n.sims){
fake <- CD4.fake (J, K)
lme.power <- lmer (y ~ time + time:treatment1 +
(1 + time | person), data=fake)
theta.hat <- fixef(lme.power)["time:treatment1"]
theta.se <- se.fixef(lme.power)["time:treatment1"]
signif[s] <- (theta.hat - 2*theta.se) > 0 # returns TRUE or FALSE
}
power <- mean (signif) # proportion of TRUE
return (power)
}
cd4.power (J=150, K=7, n.sims=10)
# power calculation function
CD4.power <- function (J, K, n.sims=1000){
signif <- rep (NA, n.sims)
for (s in 1:n.sims){
fake <- CD4.fake (J, K)
lme.power <- lmer (y ~ time + time:treatment1 +
(1 + time | person), data=fake)
theta.hat <- fixef(lme.power)["time:treatment1"]
theta.se <- se.fixef(lme.power)["time:treatment1"]
signif[s] <- (theta.hat - 2*theta.se) > 0 # returns TRUE or FALSE
}
power <- mean (signif) # proportion of TRUE
return (power)
}
cd4.power (J=150, K=7, n.sims=10)
CD4.power (J=150, K=7, n.sims=10)
# power calculation function
BHET.power <- function (mu_b3, mu_g3, mu_g4, sd_m, sd_y, n.sims=10){
te.signif <- rep (NA, n.sims)
cde.signif <- rep (NA, n.sims)
for (s in 1:n.sims){
fake <- BHET.fake (mu_b3, mu_g3, mu_g4, sd_m, sd_y)
lme.power.te <- lmer (y ~ treated + post + policy +
(1 | village), data=fake)
te.hat <- fixef(lme.power.te)["policy"]
te.se <- se.fixef(lme.power.te)["policy"]
te.signif[s] <- (te.hat - 2*te.se) > 0 # returns TRUE or FALSE
lme.power.cde <- lmer (y ~ treated + post + policy + m +
(1 | village), data=fake)
cde.hat <- fixef(lme.power.cde)["policy"]
cde.se <- se.fixef(lme.power.cde)["policy"]
cde.signif[s] <- (cde.hat - 2*cde.se) > 0 # returns TRUE or FALSE
}
power.te <- mean (te.signif)
return (power.te)
power.cde <- mean (cde.signif) # proportion of TRUE
return (power.cde)
}
BHET.power (mu_b3=10, mu_g3=5, mu_g4=5, sd_m=50, sd_y=10, n.sims=10)
BHET.power (mu_b3=10, mu_g3=5, mu_g4=5, sd_m=20, sd_y=10, n.sims=10)
BHET.power (mu_b3=1, mu_g3=5, mu_g4=5, sd_m=20, sd_y=10, n.sims=10)
BHET.power (mu_b3=1, mu_g3=5, mu_g4=2, sd_m=50, sd_y=10, n.sims=10)
BHET.power (mu_b3=10, mu_g3=10, mu_g4=5, sd_m=50, sd_y=10, n.sims=10)
test2 <- BHET.fake(10,10,5,50,10)
lme.power.ym <- lmer (y ~ treated + post + policy + log(m) + (1 | village), data=test2)
summary(lme.power.ym)
BHET.power (mu_b3=10, mu_g3=10, mu_g4=5, sd_m=50, sd_y=10, n.sims=100)
library(meta)
library(metafor)
esc_B(b=3.3,sdy=5,grp1n = 100,grp2n = 150,es.type = "g")
install.packages("meta")
library(meta)
esc_B(b=3.3,sdy=5,grp1n = 100,grp2n = 150,es.type = "g")
install.packages("esc")
library(esc)
esc_B(b=3.3,sdy=5,grp1n = 100,grp2n = 150,es.type = "g")
esc_B(b=-.5278695,sdy=1.57,grp1n = 77,grp2n = 280,es.type = "d")
8.68 / 6.94
(8.68 / 6.94) / 3
(8.68 / 6.94) / 4
esc_B(b=-.5278695,sdy=1.57,grp1n = 5000,grp2n = 10000,es.type = "d")
esc_B(b=-.5278695,sdy=1.57,grp1n = 77,grp2n = 280,es.type = "d")
esc_B(b=-.52,sdy=1.57,grp1n = 77,grp2n = 280,es.type = "d")
??pack_rows
devtools::install_github("haozhu233/kableExtra")
??kableExtra
install.packages("kableExtra")
view(dt)
dt
dt <- mtcars[1:5, 1:6]
View(dt)
??cat
library(pander)
tabl <- "  # simple table creation here
| Tables        | Are           | Cool  |
|---------------|:-------------:|------:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
test_df<-data.frame(name_column=rep(c("Lorem ipsum dolor sit amet","Only lorem"),15),
column_1=as.character(round(runif(30,10^6,2*10^6),4)),
column_2=as.character(round(runif(30,10^6,2*10^6),4)),
column_3=as.character(round(runif(30,10^6,2*10^6),4)))
View(test_df)
test_df<-data.frame(Descriptor=c("Outstanding","Excellent","Good","Fair", "Poor"),
Range=c("4.5-4.9", "4.0-4.4", "3.5-3.9", "3.0-3.4", "0.0-2.9"),
Definition=c("excels in most ", "excels in most ", "excels in most ", "excels in most ", "excels in most "))
View(test_df)
??kable
??kable_styling
devtools::install_github("benmarwick/wordcountaddin", type = "source", dependencies = TRUE)
install.packages("data.table")
devtools::install_github("benmarwick/wordcountaddin", type = "source", dependencies = TRUE)
wordcountaddin:::text_stats()
wordcountaddin:::text_stats()
wordcountaddin:::text_stats()
wordcountaddin:::readability()
devtools::install_github("noamross/redoc")
library(redoc)
devtools::install_github("crsh/prereg")
library(prereg)
wordcountaddin:::text_stats()
library(styler)
styler:::style_active_file()
setwd("~/Dropbox/arph-2020/figures/Data_Extract_From_World_Development_Indicators")
## load libraries
library(tidyverse)
library(plotly)
## Read in life expectancy data from World Bank
d <- read_csv("wdi-le.csv")
# convert to numeric
type_convert(d)
# make dataset long rather than wide
dl <- d %>%
gather(Year, LE, YR1969:YR2017)
# remove string from year
dl$Year <- str_remove(dl$Year, "YR")
# subsets of data for USA and OECD
dlusa <- subset(dl, Country.Code=="USA")
dloecd <- subset(dl, Country.Code=="OED")
# plot life expectancy over time
# highlighting relative lagging in USA
p <- ggplot(dl, aes(x=Year, y=LE, group=Country.Name)) + geom_line(colour="grey") + scale_y_continuous(limits=c(65,85)) + geom_line(data=dlusa, colour="red", size=1.5)  + theme_classic() + scale_x_discrete(breaks=c(1970, 1980, 1990, 2000, 2010, 2020), expand = c(0,2)) + annotate("text", label = "USA", x = 50, y = 78.5, size = 4, colour = "red") + ylab("Life expectancy at birth") + xlab("") + theme(axis.text.x = element_text(size = 16), axis.title.y=element_text(size=16, angle=90), axis.text.y = element_text(size = 16), legend.position="none",panel.grid.major = element_line(colour="white"), panel.grid.minor = element_line(colour="white"))
ggplotly(p)
ggsave("./figures/us-le-lagging.png", p)
ggsave("../figures/us-le-lagging.png", p)
ggsave("././figures/us-le-lagging.png", p)
ggsave("/figures/us-le-lagging.png", p)
ggsave(path="figures", file="us-le-lagging.png", plot=p)
ggsave(path="../../us-le-lagging.png", plot=p)
ggsave("../../us-le-lagging.png", plot=p)
ggsave("../../figures/us-le-lagging.png", plot=p)
ggsave("../../figures/us-le-lagging.pdf", plot=p)
